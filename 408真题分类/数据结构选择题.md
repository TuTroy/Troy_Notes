# 2010

## 3

判断后序线索树：1先写出后序序列 2根据前序后继画出线索



## 7

审题：在任何条件下都是连通的

思路：六个顶点组成完全无向图n(n-1)/2 = 15,如果有15条边的情况下，也会导致有一个顶点没有连进来，因此不满足在任何条件下，这是需要将另一个顶点连进来就好了总共15+1=16

## 9

画折半查找判定树，方形结点是虚的，不计入比较次数

最多：log2n +1 最少：1次

## 11

希尔：有个增量d

归并：分组之后再归为一组

基数：个-十-百 分趟



# 2011

## 3

入队：(rear+1)%n



## 6

![image-20231101194945149](images/image-20231101194945149.png)

特殊值法：1-1-1-1-1-....-1-116



## 7

结点值:左<根<右

![image-20231101200202431](images/image-20231101200202431.png)

> 具体方法:用前两个推后面
>
> 比如 95,22,91,24,94,71
>
> 95>22，那么后面应该是都比95小的
>
> 22<91  后面应该都是比22大的
>
> 91>24 后面应该都是比91小的，但是出现了一个94就是错的

# 2012

## 2

栈的应用：中缀转后缀

从左向右扫描，如果是操作数就输出，如果是操作符就入栈，继续扫描，如果再次扫描到操作符，和栈顶的比较优先级，优先级高就输出，低和相同就入栈(之前的出栈)，依次扫描，最终得到的输出顺序就是后缀表达式。右扣号会把左括号中间的都弹出，括号不写到输出。

##  4

N(h)=N(h-1)+N(h-2)+1



## 5

![image-20231104190911597](images/image-20231104190911597.png)

![邻接矩阵](images/邻接矩阵.jpg)

## 11

比较趟数









# 2015

# 2

> 前序序列为入栈 中序系列为出栈
>
> 对于前序序列，起始就是从根结点，将左子树的左孩子依次进栈，直到最左下角的叶子结点进栈，现在应该做的需要是让左下角的子树的右子树进栈，这时候需要把q退栈，然后回到q的父结点，只有q的父结点退栈之后才能去访问其右孩子，也就是q的兄弟结点，这个时候进栈出栈的操作，已经是按前序进栈的，然后按中序出栈了，左根右。因此只要进栈序列是前序序列，不管先后，然后随机出栈就一定是中序序列，因此可以按照卡特兰数计算。-属于出栈序列的个数问题。

![image-20231113152153519](images/image-20231113152153519.png)



## 3

> 注意给的权值就是结点的权值，只需要看其是否符合哈夫曼树

![image-20231113160434700](images/image-20231113160434700.png)



## 4

![image-20231113160749589](images/image-20231113160749589.png)

> 平衡二叉树的调整
>
> 平衡二叉树结点递推公式
>
> 平衡二叉树的旋转

![image-20231113161456052](images/image-20231113161456052.png)

![image-20231113162054105](images/image-20231113162054105.png)

## 5

> 注意不是拓扑序列0到2之后 可以去1或者3，而不是一定先去1

![image-20231113162406555](images/image-20231113162406555.png)

## 6

> 借这个题目理清一下图的算法和应用
>
> 图的算法分为DFS BFS
>
> ![image-20231113162959847](images/image-20231113162959847.png)
>
> 图的应用
>
> - 最小生成树
>
>   - Prim -- 向我汇聚
>   - Kruskal -- 权值递增选择
>
> - 最短路径
>
>   - BFS 无向图
>
>     ![image-20231113164424224](images/image-20231113164424224.png)
>
>   - Dijkstra 有向图 单源路径最短
>
>     每一轮得到一个最短路径并将其顶点加入到集合，最终会得到从源点到各个顶点的最短路径
>
>     ![image-20231113164450024](images/image-20231113164450024.png)
>
>   - Floyd 任意两点最短
>
>     有三个点A、B、C--AC刚开始不可连接，为∞或者一个很大的数，然后如果这个时候在B点，会比较AB+BC和AC的值，如果小于AC的值，就会用小的值去替换，也就是以B为中点站，A- B- C的值更新。
>
>     ![image-20231113165046102](images/image-20231113165046102.png)
>
> - 关键路径
>
>   最早开始和最晚开始，都需要先找到关键路径
>
>   时间余量=最迟发生时间-最早发生时间
>
> - 其他-拓扑序列(优先出来入度为0的点，逆拓扑是出度为0)/有向图无环图
>
>   ![image-20231113170501312](images/image-20231113170501312.png)
>
>   

![image-20231113162608901](images/image-20231113162608901.png)



## 7

> 分析：
>
> 首先知道比较判定树，左子树的值<根<右子树
>
> 而查找是从根开始的，如果进行了第一次比较，如果下一个数大于或者小于这个数，那么之后的数都会这样
>
> 如A选项，先查500，发现200<500，那么200之后的数是都要比500小的，因为此时比较到了500的左子树，只会向下继续比较，然后发现450>200的，也就是之后的数是都会比200大的，就是在区间(200,500)内查找，后面出现了180显然不在区间

![image-20231113171118984](images/image-20231113171118984.png)

> 折半查找
>
> - 查找判定树/查找效率分析
>
>   成功看成功结点，失败看失败结点个数比成功多1，前面也是用失败结点的父结点所在层数*深度
>
>   ![image-20231113171414787](images/image-20231113171414787.png)
>
> - 代码
>
>   ```c
>   typedef struct {
>     int *elem;
>     int TableLen
>   }SSTable;
>   int Binary_Search(SSTable L,int key){
>     int low=0,high=L.TableLen-1,mid;
>     while(low<=high){
>       mid=(low+high)/2;
>       if(L.elem[mid]=key){
>         return mid;
>       }else if(L.elem[mid]>key){
>         high=mid-1;
>       }else{
>         low=mid+1;
>       }
>     }//while
>     return -1;
>   }
>   ```
>
> - 常考知识点
>
>   ![image-20231113172721909](images/image-20231113172721909.png)



## 8

![image-20231113173131151](images/image-20231113173131151.png)

> 朴素比较
>
> ![image-20231113191811963](images/image-20231113191811963.png)
>
> ![image-20231113192200953](images/image-20231113192200953.png)
>
> 
>
> KMP
>
> 

## 9

> 移动次数
>
> 关键词的初始次序
>
> 1. 插入类排序
>
>    - 直接插入排序
>
>      前面是有序表，后面是无序表，比较大小并把后面的数据插入到前面去
>
>    - 希尔排序
>
>      设置一个增量分隔成若干个子序列，组内进行直接插入排序，然后不断减小增量
>
>    - 折半插入
>
>      - 折半也是前面有序表，后面无序，通过折半查找选择待插入到位置
>
>      ![image-20231113185202846](images/image-20231113185202846.png)
>
> 2. 交换类排序
>
>    - 冒泡
>    - 快速
>
> 3. 选择排序
>
>    - 简单选择排序
>    - 堆排序
>
> 4. 归并基数排序
>
>    - 归并排序
>    - 基数排序
>
> 5. 外部排序
>
> 

![image-20231113173612955](images/image-20231113173612955.png)





## 10

> 删除堆顶元素之后把数组最后一个元素补充到堆顶，然后进行调整
>
> ![img](images/110d6f442e718f86d2a1d16095513260.jpg)
>
> 如果之前上调到话会出现数组空洞情况
>
> ![img](images/5916121b08da6fc0636edf1fc24b5a81.jpg)

![image-20231113190547109](images/image-20231113190547109.png)

比较次数3









