# 指令格式

指令是计算机运行的最小功能单位。

### 4.1.1指令的基本格式

指令格式：

- 地址码：指出被操作信息(指令或数据)的地址
- 操作码：指出指令中该指令应该执行什么性质的操作和具有何种功能

**指令的字长和机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长。** 通常把指令长度等于机器字长称为单字长指令。

指令格式：

- 零地址指令，只给出操作码，没有显示地址。有两种可能：1、不需要操作数，如停机、关中断；2、参与运算的操作数隐藏在栈顶。
- 一地址指令：也分为两种：1、只有目的操作数的指令，如取反、加一等，指令含义OP($A_1$)->$A_1$；隐含目的地址的双操作数指令
- 二地址指令:指令含义($A_1$)OP($A_2$)->$A_1$
- 三地址指令：($A_1$)OP($A_2$)->$A_3$
- 四地址指令：($A_1$)OP($A_2$)->$A_3$,$A_4$为下一条要执行指令的地址

### 4.1.2扩展操作码指令格式

假设指令字长16位

4位操作码(15条三地址指令)

0000  $A_1$  $A_2$  $A_3$

0001  $A_1$  $A_2$  $A_3$

…………………………

1110  $A_1$  $A_2$  $A_3$

8位操作码(15条二地址指令)

1111  0000  $A_1$  $A_2$

1111  0001  $A_1$  $A_2$

…………………………

1111  1110  $A_1$  $A_2$

12位操作码(15条一地址指令)

1111  1111  0000  $A_1$

1111  1111  0001  $A_1$

…………………………

1111  1111  1110  $A_1$

16位操作码(16条零地址指令)

1111  1111  1111  0000

1111  1111  1111  0001

…………………………

1111  1111  1111  1111

设计操作码注意事项

- 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同
- 各指令的操作码不能重复

# 指令寻址方式

### 4.2.1指令寻址和数据寻址

- 指令寻址：寻找下一条要执行指令的地址
    - 顺序寻址：$(PC)+1$
    - 跳跃寻址：通过转移指令实现，**修改PC值，所以下一条指令仍然通过PC给出**
- 数据寻址：指令中表示一个操作数的地址，方式很多，通常在指令字中设置一个字段，用来指明那种寻址方式

| 操作码 | 寻址特征 | 形式地址A |

### 4.2.2常见的数据寻址方式

- 隐含寻址：单地址的指令格式就不明显地在地址字段中指出第二个操作数的地址，而规定累加器(ACC)作为第二操作数的地址
- 立即(数)寻址：指令地址字段指出的是操作数本身，又称立即数，数据采用补码方式。在执行阶段不访问主存，指令执行时间更短
- 直接寻址：指令中的形式地址就是物理地址A。EA=A。只需访问一次主存
- 间接寻址：给出的是操作数地址的地址。EA=(A)。间接寻址可以是一次间接寻址，还可以是多次间接寻址。间接寻址可扩大寻址范围；缺点是多次访存(一次间接访存2次)。并不常用，为了扩大寻址范围，常用寄存器间接寻址。
- 寄存器寻址：寄存器寻址在指令中给出寄存器编号。$EA=R_i$,操作数在$R_i$所指的寄存器内。不访问主存
- 寄存器间接寻址：寄存器$R_i$中不是操作数，而是操作数的地址。即$EA=(R_i)$,与一般间接寻址相比，速度更快，需要访存。
- 相对寻址：把程序计数器的内容(PC)加上指令格式中的形式地址A而得到有效地址。$EA=(PC)+A$.A是相对于当前指令地址的位移量，可正可负，补码表示。A的位数决定着操作数的寻址范围
- 基址寻址：基址寄存器(BR)的内容加上指令格式中的形式地址A而形成操作数的有效地址，即$EA=(BR)+A$.基址寄存器即可采用专用寄存器，也可采用通用寄存器。是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。
- 变址寻址：EA等于指令字中的形式地址A和变址寄存器IX的内容之和。$EA=(IX)+A$，其中IX可以为专用也可以为通用。**变址是面向用户的，使用过程中形式地址A不变，作为基址。改变变址寄存器中的内容。在处理数组时，可认为A是首地址，IX是下标**
- 堆栈寻址：堆栈是**存储器(或专用寄存器组)**中一块特定的存储区。该存储区中被读写单元的地址用堆栈指针寄存器(SP)给出
  - 硬堆栈：又称**寄存器堆栈**
  - 软堆栈：从**主存**中划分一块区域用来做堆栈
|寻址方式|有效地址|访存次数|
|-----|-----|-----|
|隐含寻址|程序指定|0|
|立即寻址|A即是操作数|0|
|直接寻址|$EA=A$|1|
|一次间接寻址|$EA=(A)$|2|
|寄存器寻址|$EA=R_i$|0|
|寄存器间接一次寻址|$EA=(R_i)$|1|
|相对寻址|$EA=(PC)+A$|1|
|基址寻址|$EA=(BR)+A$|1|
|变址寻址|$EA=(IX)+A$|1|

### 4.3 CISC和RISC
|对比项目|CISC|RISC|
|-----|-----|-----|
|指令系统|复杂，庞大|简单，精简|
|指令数目|一般大于200条|一般小于100条|
|指令字长|不固定|定长|
|可访存指令|不加限制|只有Load/Store指令|
|各种指令执行时间|相差较大|绝大多数在一个时钟周期内完成|
|各种指令使用频度|相差较大|都比较常用|
|通用寄存器数量|较少|多|
|目标代码|难以用优化编译生成高效的目标代码|采用优化的编译程序，生成代码较为高效|
|控制方式|绝大多数为微程序控制|绝大多数为组合逻辑控制|
|指令流水线|可以通过一定方式实现|必须实现|
|现实例子|X86|ARM，MIPS|

# 指令格式

 

![image-20210722234255820](../../../../AppData/Roaming/Typora/typora-user-images/image-20210722234255820.png)

![image-20210722234940065](../../../../AppData/Roaming/Typora/typora-user-images/image-20210722234940065.png)

前四种之间为定长。前四种到图中的零地址指令为变长。

![image-20210722235210355](../../../../AppData/Roaming/Typora/typora-user-images/image-20210722235210355.png)

![image-20210722235722686](../../../../AppData/Roaming/Typora/typora-user-images/image-20210722235722686.png)

定长一般用在指令长度较长的机器上，扩展一般用在指令长度较短的机器上。

![image-20210723000347409](../../../../AppData/Roaming/Typora/typora-user-images/image-20210723000347409.png)

