### 2.1 数值与编码

并不是每个十进制数都能精确地被二进制数表示，如0.3

##### BCD码 四位二进制表示十进制
- 8421码 如9为1001，位数由高到低表示8421. 如果俩个8421码相加超过1001，则需要+6修正。如1010(10)+0110(6)=0000(0)
- 余3码 在8421码的基础上加上0011(3)形成，如8->1011 9->1100
- 2421码 位数由高到低表示2421，特点是大于等于5的4位二进制中最高位为1，小于5的最高位为0.如5->1011 ,6->1100 ,4->0100

##### ASCII码
7位128个。0-9为48(0110000)-57(0111001)

##### 校验码
- 奇偶校验：只能检测出一位错误，不能确定出错的位置。在二进制中加入一位，使二进制中的"1"个数为奇数或偶数，称为奇校验和偶校验。如1001101在最高位加入校验码，奇校验11001101 偶校验01001101
- 汉明码：
```
在n=4，k=3时，求1010的汉明码
1、确定汉明码的位数
n+k<=2^k-1  (n为有效信息的位数，k为校验位)
4+3<=7，即k=3符合。所以有效信息D4D3D2D1(1010)共四位，校验位P3P2P1共三位。
所以汉明码为H7H6H5H4H3H2H1
2、确定校验位的分布
第一位校验码 P1 2^0=1,即H1=P1
P2 2^1=2，即H2=P2
P3 2^2=4，即H4=P3
所以对应为
H7H6H5H4H3H2H1
D4D3D2P3D1P2P1
3、分组已形成校验关系
被校验数据位的汉明位号等于校验该数据位的各校验位汉明位号之和
D1放在H3上，由H1和H2校验
D2放在H5上，由H1和H4校验
D3放在H6上，由H2和H4校验
D4放在H7上，由H1和H2和H4校验
4、校验位取值
放在H1上的P1负责校验D1，D2，D4，
P1=D1异或D2异或D4=0 1 1=0
P2 D1，D3，D4
P2=D1异或D3异或D4=0 0 1=1
P3 D2，D3，D4
P3=D2异或D3异或D4=1 0 1=0
所以对应汉明码为1010010
5、校验
S1=P1异或D1异或D2异或D4
S2=P2异或D1异或D3异或D4
S3=P3异或D2异或D3异或D4
若S3S2S1=000，则无错。如S3S2S1=001，则第一位出错。
```

- 循环冗余码CRC：在K位信息后拼接R位的校验码。

```
设生成多项式为G(x)=x^3+x^2+1，信息码为101001，求CRC

R=生成多项式做高位幂次=3，K=6，N=R+K=9
G(x)对应的二进制编码为1101

1、移位
将原信息左移R位，低位补0，得到101001000
2、相除
模二除法，不借位
          110101  <--商
1101 | 101001000
       1101
        1110
        1101
          1110
          1101
            1100
            1101
             001  <--余数
得到余数为001，则CRC码为101001001
3、检错和纠错
接收端收到CRC码，用生成多项式G(x)做模二除法，若余数为0，则码字无错
若接到的CRC码为C9C8C7C6C5C4C3C2C1-101001011，将这个数据与1101进行模二除法，得到余数为010，说明C2出错，C2取反即可。
```

![image-20210724165738981](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724165738981.png)

### 定点数的表示与运算

##### 移码
移码常用来表示浮点数的阶码。它只能表示整数

移码就是在真值X上加一个常数，通常这个常数取$2^n$

[x]移=$2^n+x$($-2^n=<x<2^n$，其中机器字长为n+1，包括符号位)

补码与移码符号位相反。

##### 定点数运算
- 算数位移：有符号数，移动过程符号不变。
- 逻辑位移：操作数视为无符号数，左移时，高位移丢，低位添0；右移时，低位移丢，高位添0
- 循环位移：分为带进位标识符的位移和不带进位标识符的位移。特点是：移出的数位又被移入数据中。

##### 补码定点数加减法运算
- 参与运算的两个数均用补码表示
- 按二进制运算规则，逢二进一
- **符号位与数值位规则相同，符号位产生的进位丢掉（结果和参与运算的数位数相同）**
- 补码的结果还是补码

##### 溢出
大于机器所能表示最大正数称为上溢，小于机器所能表示的最小负数称为下溢。

双符号位判断溢出，S1S2相同，表示未溢出，S1S2相同表示溢出，此时最高位符号位代表真正的符号
- $S_1S_2$=00 结果为正数，未溢出
- $S_1S_2$=01 结果正溢出
- $S_1S_2$=10 结果负溢出
- $S_1S_2$=11 结果为复数，未溢出

##### 强制类型转换
**强制类型转换的结果保持位值不变，仅改变了解释这些位的方式**

当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

### 浮点数的表示与运算
##### 浮点数一般格式
阶符-阶码的数值部分-数符-尾数的数值部分

规格化
- 左归：将位数算数左移一位，阶码减1.左归可以进行多次。
- 右归：当浮点数运算的结果位数出现溢出（双符号位01或10）时，将尾数算数右移，阶码+1.右归只需进行一次。

### IEEE754标准

数符-阶码部分(E用移码表示)-尾数数值(M用源码表示)
|类型|数符|阶码|尾数位数|总位数|偏置值|
|-----|-----|-----|-----|-----|-----|
|短浮点数(float)|1|8|23|32|7FH 127|
|长浮点数(double)|1|11|52|64|3FFH 1023|
|临时浮点数|1|15|64|80|3FFFH 16383|
短浮点数为例：最高位为数符位；其后8位阶码，以2为底，用移码表示，阶码的偏置值为2^(8-1)-1=127;其后23位为源码真值。对于规格化的二进制浮点数，数值的最高位总是“1”，为了能使尾数多表示一位有效位，通常将这个“1隐藏，由此尾数数值实际上是24位。

IEEE754浮点数的范围
|格式|最小值|最大值|
|-----|-----|-----|
|单精度|E=1，M=0,1.0\*$2^{(1-127)}$ = $2^{-126}$|E=254,M=.11…… 1.11……1\*$2^{(254-127)}$ = $2^{127}*(2 - 2^{-23})$|
|双精度|E=1，M=0，1.0\*$2^{(1-1023)}$ = $2^{-1022}$|E=2046,M=.11……, 1.11……1\*$2^{(2046-1023)}$ = $2^{1023} * (2-2^{-52})$

### 浮点数加减运算
- 对阶 小阶向大阶看齐，将阶码小的尾数右移一位，阶+1，直到阶码相等
- 尾数求和
- 规格化
    - 左归：当尾数出现00.0……或11.1……时，需要左归，即尾数左移1位，阶码减1，直到尾数为00.1……或11.0……
    - 右归：当尾数求和结果溢出（如尾数10.……或01.……）时，需要右归，即尾数右移一位，和的阶码+1
- 舍入
- 判断溢出
- 强制类型转换

### 算术逻辑单元
运算器的组成
- 算数逻辑单元
- 累加器
- 状态寄存器
- 通用寄存器组等

##### 加法器
类型
- 一位全加器
- 串行加法器：操作数长n位，则加法就要分n次进行
- 并行加法器
    - 串行进位
    - 并行进位

**ALU是一种功能较强的组合逻辑电路**


**计算机在字长足够的情况下不能精确的表示每个数**

|编码形式|最小值编码|最大值编码|范围|
|-----|-----|-----|-----|
|无符号定点整数|00……0|11……1|0 ~ $2^{(n+1)} - 1$|
|无符号定点小数|0.0……0|0.1……1|0 ~ $1 - 2^{(-n)}$|
|源码定点整数|11……1|01……1|$-2^n + 1$ ~ $2^n - 1$|
|源码定点小数|1.1……1|0.1……1|$-1 + 2^{(-n)}$ ~ $1 - 2^{(-n)}$|
|补码定点整数|10……0|01……1|$-2^n$ ~ $2^n - 1$|
|补码定点小数|1.0……0|0.1……1|-1 ~ $1 - 2^{(-n)}$|
|反码定点整数|10……0|01……1|$-2^n$ + $1 ~ 2^n - 1$|
|反码定点小数|1.0……0|0.1……1|$-1 + 2^{(-n)}$ ~ $1 - 2^{(-n)}$|
|移码定点整数|0……0|1……1|$-2^n$ ~ $2^n - 1$|



![image-20210724173225067](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724173225067.png)

 

![image-20210724173955984](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724173955984.png)

补码逆向转化为源码也是尾数取反，末位加一。可以理解为补码的补码就是原码。

![image-20210724174323250](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724174323250.png)

转码 补码 一一对应

![image-20210724174525888](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724174525888.png)

移码可以让计算机方便的判断出那个真值更大。

![image-20210724174642591](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724174642591.png)

![image-20210724175233919](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724175233919.png)

![image-20210724180023667](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724180023667.png)

原码的正数加负数必须转换成正数减正数，所以要增加加法器，增加了资源。

减去一个数就等于加上这个数的补数。

补码就是么-负数的绝对值

![image-20210724181241007](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724181241007.png)

![image-20210724181934075](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724181934075.png)

# 移位

![image-20210724205720284](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724205720284.png)

![image-20210724205819337](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724205819337.png)

![image-20210724205953702](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724205953702.png)

![image-20210724210142280](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724210142280.png)

![image-20210724210432985](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724210432985.png)

![image-20210724210637615](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724210637615.png)

按字节大端小端存储可以通过循环移位来转换

# 加减运算

![image-20210724211117522](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724211117522.png)

![image-20210724211711525](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724211711525.png)

![image-20210724211831792](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724211831792.png)

  

![image-20210724212803908](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724212803908.png)

![image-20210724213141393](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724213141393.png)

![image-20210724213322255](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724213322255.png)

第一个位表示本应得到的符号，第二位表示实际得到的符号。两个符号不同时表示有溢出。

![image-20210724213710388](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724213710388.png)

# 原码乘法运算

![image-20210724214831702](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724214831702.png)

![image-20210724215031877](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724215031877.png)

![image-20210724215629808](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724215629808.png)

![image-20210724220140169](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724220140169.png)

符号位也参与运算。

移位是算术移位。

# 强制类型转换

![image-20210724221638639](../../../../AppData/Roaming/Typora/typora-user-images/image-20210724221638639.png)

C语言不存在无符号浮点数。

## 数据存放

## 浮点数的表示

![image-20210725223608339](../../../../AppData/Roaming/Typora/typora-user-images/image-20210725223608339.png)

![image-20210725225312832](../../../../AppData/Roaming/Typora/typora-user-images/image-20210725225312832.png)

![image-20210725230324631](../../../../AppData/Roaming/Typora/typora-user-images/image-20210725230324631.png)

双符号位可以被挽救，因此在现实中是最常被使用的方式。

![image-20210725230732537](../../../../AppData/Roaming/Typora/typora-user-images/image-20210725230732537.png)

![image-20210725230804690](../../../../AppData/Roaming/Typora/typora-user-images/image-20210725230804690.png)

