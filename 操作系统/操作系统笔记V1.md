# 二、进程与线程

[进程其他相关](进程.md)

## PV操作

### 读者写者问题

> 读者：多个可以同时读
>
> 写者：写操作不允许其他操作，其他进程要退出

```c
//读写公平
Semaphore rw = 1;//读写互斥访问
Semaphore mutex = 1;//对count的互斥访问
Semaphore w = 1; //读写公平
int count = 0;//记录当前进程访问文件个数。

//写者
writer(){
  while(1){
    P(w);//防止写堵塞，一直写不上
    P(rw);
    写文件;
    V(rw);
    V(w);
  }
}

//读者
reader(){
  while(1){
    P(w);
    P(mutex);
    if(count==0)
      P(rw);
    count++;
    V(mutex);
    V(w);
    读文件;
    P(mutex);
    count--;
    if(count==0)
      V(rw);
    V(mutex);
  }
}
```



### 生产者消费者问题

> 1. 分析有几类进程，每类进程对应一个函数。
> 2. 函数内部用中文描述进程动作。重复多次加while。
> 3. 分析每个动作前是否要加P操作，有P必然要有V。
> 4. PV写完之后再去定义信号量，定义完之后再思考初值。
> 5. 检查多个P出现的地方，是否会产生死锁(尝试调整P的顺序)。
> 6. 读题检查，是否满足题目需求。

### 哲学家进餐问题

> 让进程一口气获得所有资源再运行
>
> 2019
>
> 圆桌围着n(n>=3)名哲学家，m>1个碗，哲学家之间有一只筷子
>
> 碗+两只筷子才能就餐

```c
Semaphore bowl;//用于协调哲学家对碗的使用
Semaphore chopsticks[n];//用于协调哲学家对筷子的使用
for(int i=0;i<n;i++)
  chopsticks[i]=1;
bowl=min{n-1,m}; // bowl<=1 确保不死锁

CoBegin // 并行开始
while(TRUE){
  思考;
  P(bowl);//取碗
  P(chopsticks[i]);//取左边筷子
  P(chopsticks[(i+1)%n]);//取右边筷子
  就餐;
  V(chopsticks[i]);
  V(chopsticks[(i+1)%n]);
  V(bowl);
}
CoEnd //并行结束
```



### 理发师问题

```c
Semaphore customer = 0; //理发师睡觉
Semaphore service = 0; // 服务
Semaphore mutex = 1;// 取号互斥
int waiting = 0;
// 顾客
customer(){
  P(mutex);
  //有等位区情况
  if(waiting >= MAX){
    V(mutex);
    return;
  }
  取号;
  waiting++;
  V(mutex);
  V(customer);//叫醒理发师
  等待被叫号;
  P(Service);
  被服务; 
}

//服务人员-理发师
server(){
  while(1){
    P(mutex);
    if(waiting > 0){
      叫号;
      waiting--;
      V(mutex);
      V(service);
      提供服务;
    }else{
      V(mutex);
      P(customer);//理发师睡觉
    }//else
  }//while
}
```





# 三、内存管理

[内存管理](内存管理.xmind)

[虚拟存储](虚拟存储.md)

[虚拟存储思维导图](虚拟内存管理.xmind)

# 四、文件管理

[文件系统](文件系统.md)

# 五、IO管理

[I/O](IO.xmind)

