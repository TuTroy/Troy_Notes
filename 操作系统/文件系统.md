> 补充：https://xiaolincoding.com/os/6_file_system/file_system.html

![image-20230728154540359](/Users/troy_tu/Library/Application Support/typora-user-images/image-20230728154540359.png)

打开文件--会把文件对应的inode结点读到内存(系统文件打开表)

FCB的有序集合就是文件目录

一个FCB就是文件目录项(创建新文件系统将分配一个FCB并存放在文件目录中，称为目录项)

![image-20231021195623155](images/image-20231021195623155.png)



## 文件的基本操作

> 打开和删除文件涉及到进程打开文件表
>
> 文件名不必是打开文件表的一部分，一旦完成了对FCB在磁盘上定位，系统不再使用文件名，而使用索引，Linux中叫文件描述符，Windows叫文件句柄。所有文件通过文件打开表来操作。

1. 创建文件--create系统调用
   - 在外存中找到文件所需的空间
   - 创建该文件对应的目录项(一个FCB)
2. 打开文件-- open系统调用
   - 从目录文件中找到文件名对应的目录项
   - 将目录项复制到内存中的“打开文件表”。
   - 复制(从内存到进程)到进程的"打开文件表"(编号也称索引+文件名)并将编号返回给用户，之后用户可以用编号操作文件
   - ![image-20231021191205839](images/image-20231021191205839.png)
3. 读文件 -- read
   - 需要指明是哪个文件(提供文件在打开文件表中的索引号即可)
   - 还需要指明要读入多少数据（如：读入 1KB）
   - 指明读入 的数据要放在内存中的什么位置。
4. 写文件 -- write
   - 会有个写回操作-从内存到外存
5. 关闭文件 --close
   - 将**进程**的打开文件表相应表项删除
   - 回收分配给该文件的内存空间等资源
   - 系统打开文件表的打开计数器count 减1，count==0时删除
6. 删除文件-- delete
   - 回收文件占用的磁盘块
   - 删除文件对应的目录项

![image-20231021192257400](images/image-20231021192257400.png)





## 文件共享

> 硬链接：基于索引结点
>
> - 文件的物理地址一级其他文件属性信息，不再放在目录项中，而是放在索引结点(打开文件表)中，文件的目录项只是设置文件名以及相应的指针指向索引结点。
>
> 软链接：基于符号链
>
> - 属于复制路径，count数始终和索引结点保持一致
>
> 目录查询通过在磁盘上反复搜索完成，需要不断地进行I/O操作，开销大

![image-20231021193759656](images/image-20231021193759656.png)

![image-20231021194440220](images/image-20231021194440220.png)



## 文件保护

> 口令保护-- 类似设置密码 一般口令放在索引结点或FCB中，访问时输入对比-开销小但是不够安全
>
> 加密保护-- 设置密码
>
> 访问控制--设置访问控制列表（Access-Control List, ACL）--给权限
>
> ![image-20231021195258395](images/image-20231021195258395.png)
>
> 会考到要用多少比特-存储控制矩阵





## 逻辑物理结构

![image-20231021200028763](images/image-20231021200028763.png)

无结构文件：源程序文件、目标代码文件

![image-20231021201814410](images/image-20231021201814410.png)



索引文件：把变长记录文件 记录在定长的索引表里

![image-20231021201720228](images/image-20231021201720228.png)



链接分配-不可随机访问

- 隐示链接 -通过指针顺序访问文件
- 显示链接 - 通过FAT文件分配表 类似数据结构的静态链表



## 文件存储管理

> 非空闲磁盘块的管理
>
> 空闲磁盘块的管理

![image-20231021203729668](images/image-20231021203729668.png)



Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于inode 空闲块的管理，因为 inode 也是存储在磁盘的

inode是打开文件的时候读入内存

1. 空闲表法

   > 为外存上所有空闲区建立一张空闲表
   >
   > 回收时需要注意表项的合并问题
   >
   > ![image-20231021204817379](images/image-20231021204817379.png)

2. 空闲链表

   ![image-20231021204931911](images/image-20231021204931911.png)

   系统保存链头链尾指针

3. 位示图法

   ![image-20231021205255541](images/image-20231021205255541.png)

   连续离散都适用

4. 成组链接法

   - Unix才有，适用于大型文件系统

   ![image-20231021205959837](images/image-20231021205959837.png)

   - 一个块里存放n-1个空闲块，最后一个作为下一组的超级块，以此类推

   ![image-20231021210218634](images/image-20231021210218634.png)



## 文件系统层次

![image-20231021210842977](images/image-20231021210842977.png)



![image-20231021210814866](images/image-20231021210814866.png)



## 全局结构

> 1. 空磁盘
> 2. 物理格式化(初级划分，划分扇区，并用备用扇区替换坏的)
> 3. 磁盘分区 C D E
> 4. 逻辑格式化(如下图)-也是文件系统在外存中的结构

![image-20231021211138204](images/image-20231021211138204.png)

文件系统在内存中的结构

![image-20231021211524254](images/image-20231021211524254.png)

近期访问的目录文件会换存在内存中



## 虚拟文件+挂载

> 挂载就是安装

![image-20231021212922827](images/image-20231021212922827.png)

![image-20231021213012579](images/image-20231021213012579.png)

2. VFS要求下层的文件系统必须实现某些规 定的函数功能，如：open/read/write。 一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求

3. 每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。(vnode 只存在于主存中，而 **inode 既会被调入主存，也会在外存中存储)**

   ![image-20231021213434582](images/image-20231021213434582.png)

文件挂载-将新来的文件挂载到VFS

![image-20231021213614604](images/image-20231021213614604.png)



## 磁盘

> 磁盘、磁道、扇区
>
> 盘面、柱面
>
> 物理地址
>
> 如何读写数据
>
> 磁盘分类

![image-20231021214318017](images/image-20231021214318017.png)

![image-20231021214512933](images/image-20231021214512933.png)

> **为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号)？**
>
> 答：读取地址连续的磁盘块时,采用（柱面号,盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间。

![img](images/2711b6e02a5949a89486221154f83735.png)



![image-20231021214801237](images/image-20231021214801237.png)





## 磁盘调度算法

![image-20231021215420686](images/image-20231021215420686.png)

![image-20231021215619151](images/image-20231021215619151.png)

每个磁道要可存 N 字节的数据，因此 b 字节的数据需 要 b/N 个磁道才能存储。而读/写一个磁道所需的时间 刚好又是转一圈所需要的时间 1/r



