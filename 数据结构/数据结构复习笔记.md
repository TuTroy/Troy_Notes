# 绪论

> 重点：时间空间复杂度求解

## 什么是数据

数据元素由多个数据项组成，数据项是最小的单位。

数据元素是数据的基本单位，处理数据的时候是以数据元素为一个整体进行考虑和处理。

数据对象就是相同性质数据元素的集合，集合之间存在的特定关系就是数据结构。



三要素：

- 逻辑结构
  - 集合、线性结构、树形结构、网状结构
- 数据运算
- 存储结构
  - 顺序存储 - 物理位置相邻
  - 链式存储
  - 索引存储 - 增加了索引表
  - 散列存储 - 根据元素关键词直接计算元素的存储地址



抽象数据类型ADT：数据类型定义+操作



## 复杂度

算法特征：有穷性、确定性、可行性、输入、输出

好算法：正确性、可读性、健壮性、高效低存储

### 时间复杂度

> 时间开销T(n)与问题规模n的关系
>
> 每句代码开销固定为1

```c
void loveYou(int n){// n为问题规模
 int i = 1;//爱你的程度  1 --1
 while(i<=n){        //2 ---3001
     i++;//3 --3000
     printf("I love you %d\n",i);//4 --3000
 }
 printf("I love you More Than %d\n",n)//5 --1
}
int main(){
    loveYou(3000);
}
```

T(3000)=1+3001+3000*2+1

判断

- 只考虑最高阶，使系数为1
- 加法--只保留最高阶，乘法--相乘
- 常见
  - ![图片](images/640.png)

- 如果是多层循环，则只需要关注最深层循环的次数

  - ```c
    while(i<=n){
     i = i * 2;
    }
    ```

  - ![image-20230714213028009](images/image-20230714213028009.png)

- 

### 空间复杂度

> **空间复杂度 = 递归调用的深度**

算法原地工作：算法所需内存空间为常量

~~~c
void test(int n){
 int flag[n][n];
 int i;
}

假设一个int的变量占 4B，则所需内存空间=4 * n2。
  
void test(int n){
 int flag[n][n];
 int other[n];
 int i;
}

S(n) = O(n2) + O(n)+O(1) = O(n2)
~~~





# 线性表

> n个数据元素的有限序列
>
> 一个数据元素可以由若干个数据项（item）组成，这种情况常把数据元素成为记录（record），含有大量记录的线性表又称为文件。
> $$
> (a_1,a_2,a_3...a_i,...a_n) \\
> 除第一个和最后一个元素外，每个元素有一个直接前驱和一个直接后驱
> $$
> 

线性表的基本操作

- 操作的实现基于存储结构，存储结构不同，算法实现的也不同
- 数据元素大小，C语言中用sizeof(ElemType) -- ElemType-int-float...

| 操作                | 解释                                   |
| ------------------- | -------------------------------------- |
| InitList(&L)        | 构建一个空的线性表L                    |
| ListLength(L)       | 返回L中数据元素个数                    |
| LocateElem(L,e)     | 按值查找，查找值为e的元素              |
| GetElem(L,i)        | 按位查找，获取L中第i个位置元素的值     |
| ListInsert(&L,i,e)  | 在第i个位置插入新元素e，L的长度加1     |
| ListDelete(&L,i,&e) | 删除第i个元素，并用e返回其值，L长度减1 |
| PrintList(L)        | 输出表L中的值                          |
| Empty(L)            | L为空，返回true，否则返回false         |
| DestroyList(&L)     | 摧毁L，返回其内存                      |

## 顺序表示

> 特点：
>
> - 随机访问，在O(1)的时间下找到第i个元素
> - 存储密度高，只存储数据元素
> - 扩容不方便
>
> 静态分配-表满就会溢出
>
> 动态分配-表满会自动开辟新的空间



### 静态分配

```c
//静态分配
#include <stdio.h>
#define MaxSize 10 //定义最大长度

typedef struct{
  int data[MaxSize];
  int length;
}SqList;

//init
void InitList(SqList *L){
  for(int i=0;i<MaxSize;i++)
    L->data[i]=0;
  L->length=0;
}

//main
int main(){
  SqList L;
  InitList(&L);
  //测试
  for(int i=0;i<MaxSize;i++){
    printf("L.data[%d]=%d\n",i,L.data[i]);
  }
  return 0;
}

```

### 动态分配

```c
//C动态分配语句
//mallo函数返回的实际是一个无类型指针，必须在其前面加上指针类型强制转换才可以使用
L.data=(ElemType *)malloc(sizeof(ElemType)*InitSize);
//C++动态分配
L.data=new ElemType[InitSize];
```



```c
//动态分配
#include <stdio.h>
#include <stdlib.h>
#define InitSize 10 //表长初始定义

typedef struct{
  int *data;//动态分配数组指针
  int MaxSize,length;
}SeqList;

//init
void InitList(SeqList *L){
  L->data=(int *)malloc(InitSize*sizeof(int));
  L->length=0;
  L->MaxSize=InitSize;
}

//增加动态数组的长度
void IncreaseSize(SeqList *L,int len){
  int *p=L->data;// 保存旧的数据指针
  L->data=(int *)malloc((L->MaxSize+len)*sizeof(int));// 重新分配更大的内存空间
  for(int i=0;i<L->length;i++){// 将旧数据复制到新内存空间
    L->data[i]=p[i];
  }
  L->MaxSize=L->MaxSize+len; //更新最大长度
  free(p); //释放旧的内存空间
}

//main
int main(){
  SeqList L;
  InitList(&L);
  IncreaseSize(&L,5);
  //测试元素
  for(int i=0;i< L.MaxSize;i++){ //此时L是一个结构体而不是指针，因此需要用L.MaxSize表示不能用L->MaxSize
    printf("L.data[%d]=%d\n",i,L.data[i]); 
  }
  return 0;
}
```

### 插入

> 代码实现+复杂度分析

```c
//静态分配
#include <stdio.h>
#include <stdbool.h>
#define MaxSize 10 //定义最大长度
// #define true 1
// #define false 0

typedef struct{
  int data[MaxSize];
  int length;
}SqList;

//init
void InitList(SqList *L){
  for(int i=0;i<MaxSize;i++)
    L->data[i]=0;
  L->length=0;
}

//插入
bool ListInsert(SqList *L,int i ,int e){ //在i处插入e
    if(i<1||i>L->length+1)
        return false;
    if(L->length>=MaxSize)
        return false;
    for(int j=L->length;j>=i;j--)
        L->data[j]=L->data[j-1];
    L->data[i-1]=e;
    L->length++;
    return true;
}

//main
int main(){
  SqList L;
  InitList(&L);
  ListInsert(&L,1,5);
  for(int i=0;i<MaxSize;i++){
    printf("L.data[%d]=%d\n",i,L.data[i]);
  }
  return 0;
}
```















## 链式表示







# 栈、队列和数组

# 串

# 树与二叉树

# 图

# 查找

# 排序

